
-- Utility to run scripts concurrently
local function RunConcurrent(fn)
    task.spawn(fn)
end

-- === REJOIN_BYPASS ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()

    local function rejoinServer()
        local ts = game:GetService("TeleportService")
        local p = game:GetService("Players").LocalPlayer
        ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
    end

    function MainSequence()
        task.wait(_G.Configs["Rejoin_Second"])
        rejoinServer()
    end

    MainSequence()
end)

-- === SCRIPT1_2 ===
RunConcurrent(function()
    -- ========================================
    -- COMBINED ROBLOX SCRIPT
    -- Phase 1: Titan Script -> Phase 2: Naruto Script
    -- ========================================
    if _G.Configs["Farm Mode"] == "OP" then
        repeat task.wait() until game:IsLoaded()
        task.wait(6)
        -- ========================================
        -- PHASE 1: TITAN SCRIPT (CODE NO. 1)
        -- ========================================

        local Players = game:GetService("Players")
        local VirtualInputManager = game:GetService("VirtualInputManager")
        local player = Players.LocalPlayer
        local titanFolder = workspace:WaitForChild("Titans")

        local pressed1 = false
        local pressed2 = false
        local stopLoop = false

        -- Function to anchor character to prevent movement
        local function AnchorCharacter()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")

            if hrp then
                hrp.Anchored = true
                -- Store original position
                return hrp.CFrame
            end
            return nil
        end

        -- Function to unanchor character
        local function UnanchorCharacter()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Anchored = false
            end
        end

        -- จำลองการกดปุ่ม 1 (with anti-movement)
        task.delay(1, function()
            local originalPos = AnchorCharacter()

            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.One, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.One, false, game)

            -- Wait a bit for skill animation, then restore position
            task.wait(0.5)
            if originalPos then
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = originalPos
                end
            end

            UnanchorCharacter()
            pressed1 = true
        end)

        -- จำลองการกดปุ่ม 2 (with anti-movement)
        task.delay(4, function()
            local originalPos = AnchorCharacter()

            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)

            -- Wait a bit for skill animation, then restore position
            task.wait(0.5)
            if originalPos then
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = originalPos
                end
            end

            UnanchorCharacter()
            pressed2 = true
        end)

        -- ตรวจสอบและหยุด loop เมื่อกดครบ
        task.spawn(function()
            while not stopLoop do
                if pressed1 and pressed2 then
                    stopLoop = true
                end
                task.wait(0.1)
            end
        end)

        -- ฟังก์ชันดึงไททันทั้งหมด
        local function getAllTitansInFolder(folder)
            local titans = {}

            for _, descendant in pairs(folder:GetDescendants()) do
                if descendant:FindFirstChild("HumanoidRootPart") then
                    table.insert(titans, descendant)
                end
            end

            return titans
        end

        -- ฟังก์ชันย้ายและขยาย Nape
        local function moveAllNapesLowerInFront()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local distance = 30
            local dropAmount = 5
            local lookVector = hrp.CFrame.LookVector
            local frontPosition = hrp.Position + lookVector * distance
            local loweredPosition = frontPosition - Vector3.new(0, dropAmount, 0)

            local allTitans = getAllTitansInFolder(titanFolder)

            for _, titan in pairs(allTitans) do
                local nape = titan:FindFirstChild("Hitboxes", true)
                    and titan.Hitboxes:FindFirstChild("Hit", true)
                    and titan.Hitboxes.Hit:FindFirstChild("Nape")

                if nape and nape:IsA("BasePart") then
                    nape.Size = Vector3.new(50, 50, 50)
                    nape.CFrame = CFrame.new(loweredPosition, loweredPosition + lookVector)
                end
            end
        end

        -- Loop หลักของ Phase 1
        while true do
            if stopLoop then
                break
            end
            moveAllNapesLowerInFront()
            task.wait(0.05)
        end
    end

    -- ========================================
    -- TRANSITION PHASE
    -- ========================================


    -- ========================================
    -- PHASE 2: NARUTO SCRIPT (CODE NO. 2)
    -- ========================================

    --setfpscap(17) -- Increased from 15 for smoother performance
    task.wait(1)

    -- Services
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local UserInputService = game:GetService("UserInputService")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    -- Remotes with better error handling
    local Assets = ReplicatedStorage:WaitForChild("Assets", 10)
    if not Assets then
        return
    end

    local Remotes = Assets:WaitForChild("Remotes", 10)
    if not Remotes then
        return
    end

    local POST = Remotes:WaitForChild("POST", 10)
    local GET = Remotes:WaitForChild("GET", 10)

    if not POST or not GET then
        return
    end

    local LocalPlayer = Players.LocalPlayer

    -- CONFIGURATION SECTION
    -- Base wait time before allowing last titan kill (in seconds)
    local BASE_WAIT_TIME = _G.Configs["BASE_WAIT_TIME"] -- Change this value as needed

    -- Random delay range to add to the base wait time
    -- Set the minimum and maximum additional seconds to add to the base wait time
    -- Example: {1, 3} will add 1-3 random seconds, {1, 5} will add 1-5 random seconds
    local RANDOM_DELAY_CONFIG = { 1, 5 } -- Change these values as needed

    -- Optimized Variables
    local State = {
        baitDummy = nil,
        lastKillValue = -1,
        lastKillTime = tick(),
        lastReloadedKill = -5,
        hasEscaped = false,
        noKillCount = 0,
        isAttacking = false,
        lastActionTime = tick(),
        maxIdleTime = 8, -- Reduced for better responsiveness
        isImmortal = false,
        lastHealthCheck = 0,
        titanCache = {},
        lastTitanCheck = 0,
        gameStartTime = tick(), -- Track when the game/script started
        randomDelayTime = 0     -- Will store the random delay time
    }

    -- Optimized character waiting
    local function WaitForCharacter()
        local startTime = tick()
        repeat
            task.wait(0.1)
            if tick() - startTime > 30 then -- Timeout after 30 seconds
                return false
            end
        until LocalPlayer.Character
            and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            and not LocalPlayer.Character:FindFirstChild("ForceField")

        task.wait(1) -- Reduced wait time
        return true
    end

    -- Optimized HUD waiting with timeout
    local function WaitForKillHUD()
        local startTime = tick()

        while tick() - startTime < 20 do -- 20 second timeout
            local success, result = pcall(function()
                local gui = LocalPlayer:FindFirstChild("PlayerGui")
                if not gui then return false end

                local hudPath = gui:FindFirstChild("Interface")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("HUD")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Objectives")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Main")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Slay")
                if not hudPath then return false end

                local text = hudPath.Text
                return text and string.match(text, "%[(%d+)%/") ~= nil
            end)

            if success and result then
                return true
            end

            task.wait(0.5)
        end

        return false
    end

    -- Function to generate random delay time (called once at script start)
    local function GenerateRandomDelay()
        if #RANDOM_DELAY_CONFIG >= 2 then
            local minDelay = math.min(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
            local maxDelay = math.max(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
            return math.random(minDelay, maxDelay)
        else
            return 0 -- No delay if config is invalid
        end
    end

    -- Function to check if required time has passed since game start (base time + random delay)
    local function HasRequiredTimePassed()
        local requiredTime = BASE_WAIT_TIME + State.randomDelayTime
        return (tick() - State.gameStartTime) >= requiredTime
    end

    -- Function to get total required wait time
    local function GetTotalRequiredTime()
        return BASE_WAIT_TIME + State.randomDelayTime
    end

    -- Optimized dummy creation
    local function CreateBaitDummy()
        pcall(function()
            if State.baitDummy then
                State.baitDummy:Destroy()
                State.baitDummy = nil
            end

            local char = LocalPlayer.Character
            if not char or not char.PrimaryPart then return end

            State.baitDummy = char:Clone()
            State.baitDummy.Name = "BaitDummy_" .. math.random(1000, 9999)
            State.baitDummy.Parent = workspace

            -- Position dummy above character
            State.baitDummy:SetPrimaryPartCFrame(char.PrimaryPart.CFrame * CFrame.new(0, 8, 0))

            -- Optimize dummy properties in batch
            local descendants = State.baitDummy:GetDescendants()
            for i = 1, #descendants do
                local part = descendants[i]
                if part:IsA("BasePart") then
                    part.Anchored = true
                    part.CanCollide = false
                    part.Material = Enum.Material.ForceField -- Lighter rendering
                elseif part:IsA("Humanoid") then
                    part.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                    part.PlatformStand = true
                    part.BreakJointsOnDeath = false
                    part.Health = part.MaxHealth
                end
            end
        end)
    end

    -- Optimized hiding function
    local function HideCharacter()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = CFrame.new(math.random(-100, 100), -5000, math.random(-100, 100))
        end
    end

    -- Optimized invisibility function
    local function BecomeInvisible()
        local char = LocalPlayer.Character
        if not char then return end

        pcall(function()
            local descendants = char:GetDescendants()
            for i = 1, #descendants do
                local obj = descendants[i]
                if obj:IsA("BasePart") then
                    obj.Transparency = 1
                    obj.CanCollide = false
                elseif obj:IsA("Decal") then
                    obj.Transparency = 1
                elseif obj:IsA("ParticleEmitter") or obj:IsA("Beam") then
                    obj.Enabled = false
                end
            end

            -- Handle accessories
            local children = char:GetChildren()
            for i = 1, #children do
                local acc = children[i]
                if acc:IsA("Accessory") then
                    local handle = acc:FindFirstChild("Handle")
                    if handle then
                        handle.Transparency = 1
                        handle.CanCollide = false
                    end
                end
            end
        end)
    end

    -- Enhanced immortality system
    local function MakeImmortal()
        if State.isImmortal then return end

        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if not humanoid then
            return
        end

        pcall(function()
            -- Rename humanoid to avoid detection
            humanoid.Name = "H_" .. math.random(10000, 99999)

            -- Set immortal properties
            humanoid.MaxHealth = 1e6
            humanoid.Health = humanoid.MaxHealth
            humanoid.BreakJointsOnDeath = false
            humanoid.RequiresNeck = false

            -- Continuous health monitoring (optimized)
            local healthConnection
            healthConnection = RunService.Heartbeat:Connect(function()
                if not humanoid or not humanoid.Parent or not char or not char.Parent then
                    if healthConnection then
                        healthConnection:Disconnect()
                    end
                    State.isImmortal = false
                    return
                end

                -- Only check health every 0.1 seconds for performance
                local currentTime = tick()
                if currentTime - State.lastHealthCheck >= 0.1 then
                    State.lastHealthCheck = currentTime
                    if humanoid.Health < humanoid.MaxHealth * 0.9 then
                        humanoid.Health = humanoid.MaxHealth
                    end
                end
            end)

            State.isImmortal = true
            HideCharacter()
            CreateBaitDummy()
        end)
    end

    -- Optimized reload function
    local function Reload()
        pcall(function()
            local gasStation = workspace:FindFirstChild("Unclimbable")
            if gasStation then
                gasStation = gasStation:FindFirstChild("Reloads")
                if gasStation then
                    gasStation = gasStation:FindFirstChild("GasTanks")
                    if gasStation then
                        gasStation = gasStation:FindFirstChild("Refill")
                        if gasStation then
                            POST:FireServer("Attacks", "Reload", gasStation)
                            State.lastActionTime = tick()
                            return
                        end
                    end
                end
            end

            -- Fallback reload
            POST:FireServer("Attacks", "Reload")
            State.lastActionTime = tick()
        end)
    end

    -- Optimized R key press
    local function PressR()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
            task.wait(0.05) -- Reduced wait time
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
            State.lastActionTime = tick()
        end)
    end

    -- Smoother teleportation around nape
    local function TeleportAroundNape(nape, count, radius)
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root or not nape then return false end

        pcall(function()
            local baseHeight = 8
            for i = 1, count do
                local angle = math.rad((360 / count) * i + math.random(-15, 15))
                local currentRadius = radius + math.random(-1, 1)
                local height = baseHeight + math.sin(tick() * 3 + i) * 2

                local offsetX = math.cos(angle) * currentRadius
                local offsetZ = math.sin(angle) * currentRadius

                local targetCFrame = nape.CFrame * CFrame.new(offsetX, height, offsetZ)
                root.CFrame = targetCFrame

                task.wait(0.03) -- Smoother movement
            end
        end)
        return true
    end

    -- Optimized kill count function
    local function GetCurrentKillCount()
        local success, result = pcall(function()
            local gui = LocalPlayer.PlayerGui
            local text = gui.Interface.HUD.Objectives.Main.Slay.Text
            return tonumber(string.match(text, "%[(%d+)%/"))
        end)
        return success and result or State.lastKillValue
    end

    -- Enhanced titan attack function
    local function AttackTitan(titan)
        if State.isAttacking then return end
        State.isAttacking = true

        local success = pcall(function()
            -- Find nape with better error handling
            local hitboxes = titan:FindFirstChild("Hitboxes", true)
            if not hitboxes then
                return
            end

            local hit = hitboxes:FindFirstChild("Hit")
            if not hit then
                return
            end

            local nape = hit:FindFirstChild("Nape")
            if not nape then
                return
            end


            -- Prepare for attack
            BecomeInvisible()
            MakeImmortal()

            -- Optimize nape hitbox
            nape.Size = Vector3.new(25, 25, 25) -- Larger hitbox for better hit detection
            nape.CanCollide = false
            nape.Transparency = 1
            nape.Shape = Enum.PartType.Ball -- Better collision detection

            -- Enhanced teleportation
            if not TeleportAroundNape(nape, 3, 5) then
                return
            end

            -- Improved attack sequence
            local attackSequence = {
                function() POST:FireServer("Attacks", "Slash", true) end,
                function() task.wait(0.02) end,
                function() POST:FireServer("Hitboxes", "Register", nape, 9999, 0.05) end,
                function() task.wait(0.02) end,
                function() POST:FireServer("Attacks", "Slash", false) end
            }

            for i, action in ipairs(attackSequence) do
                action()
            end

            -- Check kill progress
            local currentKill = GetCurrentKillCount()
            if currentKill and currentKill > State.lastKillValue then
                State.lastKillValue = currentKill
                State.lastKillTime = tick()
                State.lastActionTime = tick()
                State.hasEscaped = false
                State.noKillCount = 0
            end

            -- Smart escape mechanism
            local timeSinceKill = tick() - State.lastKillTime
            if timeSinceKill >= 2 and not State.hasEscaped then
                State.hasEscaped = true
                POST:FireServer("Attacks", "Slash_Escape")
                State.lastKillTime = tick()
            end

            -- Smart reload system
            if currentKill and currentKill % 7 == 0 and currentKill ~= State.lastReloadedKill then
                Reload()
                State.lastReloadedKill = currentKill
            end

            -- Timeout handling
            if timeSinceKill >= 2 then
                PressR()
                Reload()
                State.lastKillTime = tick()
                State.noKillCount = State.noKillCount + 1

                if State.noKillCount >= 2 then
                    PressR()
                    State.noKillCount = 0
                end
            end
        end)

        if not success then
            -- Error handling
        end

        State.isAttacking = false
        State.lastActionTime = tick()
    end

    -- Optimized visibility restoration
    local function MakeVisible()
        local char = LocalPlayer.Character
        if not char then return end

        pcall(function()
            local descendants = char:GetDescendants()
            for i = 1, #descendants do
                local part = descendants[i]
                if part:IsA("BasePart") then
                    part.Transparency = 0
                    part.CanCollide = true
                elseif part:IsA("Decal") then
                    part.Transparency = 0
                elseif part:IsA("ParticleEmitter") or part:IsA("Beam") then
                    part.Enabled = true
                end
            end

            local children = char:GetChildren()
            for i = 1, #children do
                local acc = children[i]
                if acc:IsA("Accessory") then
                    local handle = acc:FindFirstChild("Handle")
                    if handle then
                        handle.Transparency = 0
                        handle.CanCollide = true
                    end
                end
            end
        end)
    end

    -- Enhanced script reset
    local function ResetScript()
        pcall(function()
            if State.baitDummy then
                State.baitDummy:Destroy()
                State.baitDummy = nil
            end
        end)

        State.lastKillValue = -1
        State.lastKillTime = tick()
        State.lastReloadedKill = -5
        State.hasEscaped = false
        State.noKillCount = 0
        State.isAttacking = false
        State.lastActionTime = tick()
        State.isImmortal = false
        State.titanCache = {}
        State.lastTitanCheck = 0
        -- Don't reset gameStartTime as we want to keep track from the very beginning
    end

    -- Optimized titan detection with caching
    local function GetTitans()
        local currentTime = tick()
        if currentTime - State.lastTitanCheck < 0.2 then -- Cache for 0.2 seconds
            return State.titanCache
        end

        State.lastTitanCheck = currentTime
        State.titanCache = {}

        local success, titans = pcall(function()
            local titanFolder = workspace:FindFirstChild("Titans")
            return titanFolder and titanFolder:GetChildren() or {}
        end)

        if success then
            -- Filter valid titans
            for i = 1, #titans do
                local titan = titans[i]
                if titan and titan.Parent and titan:FindFirstChild("Hitboxes", true) then
                    table.insert(State.titanCache, titan)
                end
            end
        end

        return State.titanCache
    end

    -- Function to check if we should attack the last titan
    local function ShouldAttackLastTitan(titanCount)
        if titanCount ~= 1 then
            return true -- Not the last titan, attack normally
        end

        -- This is the last titan, check if required time has passed
        return HasRequiredTimePassed()
    end

    -- Initialize Phase 2

    if not WaitForCharacter() then
        error("❌ Failed to load character for Phase 2")
    end

    WaitForKillHUD()
    ResetScript()

    -- Generate the random delay time once at the start
    State.randomDelayTime = GenerateRandomDelay()

    -- Main optimized loop for Phase 2
    while true do
        local loopStart = tick()

        -- Anti-hang protection
        if tick() - State.lastActionTime > State.maxIdleTime then
            ResetScript()
            PressR()
        end

        -- Character validation
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            LocalPlayer:LoadCharacter()
            if not WaitForCharacter() then
                continue
            end
            WaitForKillHUD()
            ResetScript()
            task.wait(1)
            continue
        end

        -- Get titans with caching
        local titans = GetTitans()

        if #titans == 0 then
            task.wait(1)
        elseif #titans == 1 then
            -- Single titan strategy with timing check
            if not ShouldAttackLastTitan(#titans) then
                -- Wait for required time to pass before attacking the last titan
                local timeRemaining = GetTotalRequiredTime() - (tick() - State.gameStartTime)
                if timeRemaining > 0 then
                    task.wait(1)
                    continue
                end
            end

            if State.baitDummy then
                pcall(function() State.baitDummy:Destroy() end)
                State.baitDummy = nil
            end

            local titan = titans[1]
            pcall(function()
                char:PivotTo(titan:GetPivot() * CFrame.new(0, 6, -12))
                MakeVisible()
            end)

            AttackTitan(titan)
            task.wait(0.3)
        else
            -- Multiple titans strategy - attack all except potentially the last one
            for i = 1, #titans do
                local isLastTitan = (i == #titans and #titans > 1) -- Check if this is the last titan in a multi-titan scenario

                if not isLastTitan or ShouldAttackLastTitan(1) then
                    AttackTitan(titans[i])
                    task.wait(0.05)
                end
            end
        end

        task.wait(0.05) -- Smooth loop timing
    end
end)

-- === SLOT ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer

    local function MainSequence()
        task.wait(15)
        local selectArgs = { "Functions", "Select", "A" }
        ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(selectArgs))

        local teleportArgs = { "Functions", "Teleport", "Lobby" }
        ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(teleportArgs))
    end

    local success, result = pcall(function()
        return LocalPlayer
            :WaitForChild("PlayerGui")
            :WaitForChild("Interface")
            :WaitForChild("Title_Screen")
            :WaitForChild("Slots").Name
    end)

    if success and typeof(result) == "string" then
        MainSequence()
    else
        warn("ไม่สามารถดึง Slot หรือค่าไม่ใช่ string")
    end
end)

-- === CHECK_RETRY ===
RunConcurrent(function()
    -- รอให้เกมโหลดเสร็จ
    repeat task.wait() until game:IsLoaded()

    -- ประกาศ Services
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local delayTime = math.random() * (3.7 - 1.0) + 1.0

    -- การตั้งค่า
    local CONFIG = {
        CLICK_DELAY = 0.1,                    -- ลดเวลารอระหว่างคลิก
        CHECK_INTERVAL = 0.5,                 -- ตรวจสอบทุก 0.5 วินาที
        INITIAL_WAIT = 5,                     -- รอเริ่มต้น 5 วินาที
        STUCK_TIMEOUT = 20,                   -- ถ้า Kill ไม่เปลี่ยน 20 วินาที จะคลิก
        CLICK_POSITION = _G.Configs["PositionXY"],
    }

    -- ตัวแปรสำหรับติดตาม Kill count
    local lastKillCount = nil
    local lastChangeTime = tick()

    -- 🖱 ฟังก์ชันคลิกซ้ายที่แก้ไขแล้ว
    local function SimulateLeftClick(x, y)
        local pos = { x = x or CONFIG.CLICK_POSITION.x, y = y or CONFIG.CLICK_POSITION.y }


        -- วิธีที่ 1: ใช้ VirtualInputManager (แก้ไขให้ถูกต้อง)
        local clickSuccess = pcall(function()
            -- เลื่อนเมาส์ไปยังตำแหน่งที่ถูกต้อง
            VirtualInputManager:SendMouseMoveEvent(pos.x, pos.y, game)
            task.wait(CONFIG.CLICK_DELAY)

            -- คลิกซ้าย - ใช้พารามิเตอร์ที่ถูกต้อง
            -- SendMouseButtonEvent(x, y, button, pressed, game, [button_number])
            VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, true, game, 1)
            task.wait(CONFIG.CLICK_DELAY)
            VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, false, game, 1)
        end)

        if not clickSuccess then
            -- วิธีที่ 2: ใช้ Mouse object (สำรอง)
            pcall(function()
                if LocalPlayer and LocalPlayer:GetMouse() then
                    local mouse = LocalPlayer:GetMouse()

                    -- พยายามเลื่อนเมาส์ด้วยวิธีอื่น
                    mouse.X = pos.x
                    mouse.Y = pos.y

                    -- จำลองการคลิกผ่าน Mouse events
                    for i = 1, 1 do -- ลดจาก 2 เป็น 1 ครั้ง
                        if mouse.Button1Down then
                            mouse.Button1Down:Fire()
                        end
                        task.wait(CONFIG.CLICK_DELAY)
                        if mouse.Button1Up then
                            mouse.Button1Up:Fire()
                        end
                        task.wait(CONFIG.CLICK_DELAY)
                    end
                end
            end)
        end

        -- เพิ่มการยืนยันตำแหน่ง
        task.wait(0.1)
        local mouse = LocalPlayer:GetMouse()
        if mouse then
            local actualX, actualY = mouse.X, mouse.Y

            -- ตรวจสอบว่าตำแหน่งถูกต้องหรือไม่
            local xDiff = math.abs(actualX - pos.x)
            local yDiff = math.abs(actualY - pos.y)
        end
    end

    -- 🔍 ฟังก์ชันดึงข้อมูล Kill count
    local function GetKillData()
        local success, result = pcall(function()
            local interface = LocalPlayer.PlayerGui:FindFirstChild("Interface")
            if not interface then return nil end

            local hud = interface:FindFirstChild("HUD")
            if not hud then return nil end

            local objectives = hud:FindFirstChild("Objectives")
            if not objectives then return nil end

            local main = objectives:FindFirstChild("Main")
            if not main then return nil end

            local slay = main:FindFirstChild("Slay")
            if not slay then return nil end

            return slay.Text
        end)

        return success and result or nil
    end

    -- 📊 ฟังก์ชันแปลงข้อความเป็นตัวเลข
    local function ParseKillText(text)
        if not text then return nil, nil end

        local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
        return tonumber(current), tonumber(max)
    end

    -- 🎯 ฟังก์ชันหลักที่ปรับปรุงแล้ว
    local function MainSequence()
        while true do
            local killText = GetKillData()
            local currentTime = tick()

            if killText then
                local currentKill, maxKill = ParseKillText(killText)

                if currentKill and maxKill then
                    -- ตรวจสอบว่า Kill count เปลี่ยนแปลงหรือไม่
                    if lastKillCount ~= currentKill then
                        lastKillCount = currentKill
                        lastChangeTime = currentTime
                    end

                    -- ตรวจสอบว่าครบแล้วหรือไม่
                    if currentKill >= maxKill then
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        break
                    end

                    -- ตรวจสอบว่า Kill ค้างไม่เปลี่ยนเกิน timeout หรือไม่
                    local timeSinceLastChange = currentTime - lastChangeTime
                    if timeSinceLastChange >= CONFIG.STUCK_TIMEOUT then
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        lastChangeTime = currentTime -- รีเซ็ตเวลา
                        task.wait(delayTime)         -- รอให้ระบบประมวลผล
                    end
                end
            else
            end

            task.wait(CONFIG.CHECK_INTERVAL)
        end
    end

    -- 🔧 ฟังก์ชันเริ่มต้นพร้อมการจัดการข้อผิดพลาด
    local function Initialize()
        task.wait(CONFIG.INITIAL_WAIT)

        -- ตรวจสอบว่า LocalPlayer พร้อมใช้งาน
        if not LocalPlayer then
            return
        end


        -- รีเซ็ตเวลาเริ่มต้น
        lastChangeTime = tick()

        -- เริ่มการทำงานหลัก
        local success, err = pcall(MainSequence)
        if not success then
            return
        end
    end

    -- 🧪 ฟังก์ชันทดสอบคลิก (เพิ่มเติม)
    local function TestClick()
        SimulateLeftClick()
    end

    -- เปิดใช้ฟังก์ชันทดสอบ
    _G.TestClick = TestClick

    Initialize()
end)

-- === MISSION ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    task.wait(13)

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RemoteFunction = ReplicatedStorage.Assets.Remotes.GET

    local gold = Players.LocalPlayer.PlayerGui.Interface.Topbar.Main.Currencies.Gold.Amount.Text
    local gradeText = Players.LocalPlayer.PlayerGui.Interface.Equipment.Categories.Upgrades.Main.Title.Text

    local extractedGrade = string.match(gradeText, "%[(%a%+?%-?)%s*GRADE%]")

    local maxChecks = _G.Configs["MaxChecks"]

    local upgrades = {
        "ODM_Control",
        "ODM_Speed",
        "ODM_Gas",
        "ODM_Damage",
        "Blade_Durability",
        "Crit_Chance",
        "Crit_Damage"
    }

    local function performFixedRounds()
        for round = 1, maxChecks do
            print("Fixed round " .. round .. " of " .. maxChecks)
            for _, upgradeName in ipairs(upgrades) do
                RemoteFunction:InvokeServer(unpack({
                    "S_Equipment",
                    "Upgrade",
                    upgradeName
                }))
                task.wait(0.2)
            end
        end
    end

    local function performUntilSilent()
        while true do
            local allNil = true
            for _, upgradeName in ipairs(upgrades) do
                local result = RemoteFunction:InvokeServer(unpack({
                    "S_Equipment",
                    "Upgrade",
                    upgradeName
                }))
                if result ~= nil then
                    allNil = false
                end
                task.wait(0.2)
            end
            if allNil then
                print("All upgrades returned nil. Stopping.")
                break
            else
                print("Some upgrades not nil yet. Continuing...")
                task.wait(1)
            end
        end
    end

    local function createMission(difficulty, missionType, name, objective)
        local args = { "S_Missions", "Create", {
            ["Difficulty"] = difficulty,
            ["Type"] = missionType,
            ["Name"] = name,
            ["Objective"] = objective
        } }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    local function modifyMission(modifier)
        local args = { "S_Missions", "Modify", modifier }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    local function startMission()
        local args = { "S_Missions", "Start" }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    if typeof(gold) == "string" then
        if extractedGrade == "S" or extractedGrade == "S+" or extractedGrade == "S-" then
            print("Grade is already S-level. Skipping upgrades.")
        else
            print("Grade is below S.")

            if maxChecks > 0 then
                print("Performing fixed " .. maxChecks .. " rounds of upgrades...")
                performFixedRounds()
            else
                print("Performing upgrades until all return nil...")
                performUntilSilent()
            end
        end

        local create_or_not = _G.Configs["Auto Create Mission"]
        if create_or_not == true then
            createMission(_G.Configs["Mission Difficulty"], "Missions", "Shiganshina", "Skirmish")

        for _, modifier in ipairs(_G.Configs["Modifiers"]) do
            modifyMission(modifier)
            task.wait(0.1)
        end

        startMission()
    else
        warn("gold ไม่ใช่ string")
    end
end)





-- === BLACK OVERLAY ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    task.wait(5)
    -- Black Screen Overlay with Kill Counter (Ultra Lightweight)
    -- This creates a black overlay with kill counter that doesn't consume much resources

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    -- Wait for PlayerGui
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    -- Variables for kill tracking
    local killLabel = nil
    local lastUpdateTime = 0

    -- Optimized kill count function
    local function GetKillInfo()
        local success, currentKill, maxKill = pcall(function()
            local gui = LocalPlayer.PlayerGui
            local text = gui.Interface.HUD.Objectives.Main.Slay.Text
            local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
            return tonumber(current), tonumber(max)
        end)
        return success and currentKill or 0, success and maxKill or 0
    end

    -- Create the black overlay with kill counter
    local function CreateBlackOverlay()
        -- Check if overlay already exists
        local existingOverlay = playerGui:FindFirstChild("BlackOverlay")
        if existingOverlay then
            existingOverlay:Destroy()
        end

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "BlackOverlay"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.DisplayOrder = -1000 -- Put it behind other UIs
        screenGui.Parent = playerGui

        -- Create black frame
        local blackFrame = Instance.new("Frame")
        blackFrame.Name = "BlackFrame"
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.Position = UDim2.new(0, 0, 0, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0) -- Pure black
        blackFrame.BorderSizePixel = 0
        blackFrame.Active = false                         -- Don't capture input
        blackFrame.Parent = screenGui

        -- Create kill counter label (simple white text)
        killLabel = Instance.new("TextLabel")
        killLabel.Name = "KillCounter"
        killLabel.Size = UDim2.new(0, 200, 0, 50)
        killLabel.Position = UDim2.new(0.5, -100, 0.5, -25) -- Center of screen
        killLabel.BackgroundTransparency = 1                -- Transparent background
        killLabel.Text = "Kills: 0/0"
        killLabel.TextColor3 = Color3.new(1, 1, 1)          -- White text
        killLabel.TextSize = 24
        killLabel.Font = Enum.Font.Code                     -- Simple font
        killLabel.TextStrokeTransparency = 0.5              -- Slight outline for visibility
        killLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        killLabel.Active = false
        killLabel.Parent = blackFrame


        return screenGui
    end

    -- Create the overlay
    local overlay = CreateBlackOverlay()

    -- Ultra lightweight update function (updates only every 0.5 seconds)
    local connection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - lastUpdateTime >= 0.5 and killLabel and killLabel.Parent then -- Update every 0.5 seconds only
            lastUpdateTime = currentTime
            local currentKill, maxKill = GetKillInfo()
            killLabel.Text = string.format("Kills: %d/%d", currentKill, maxKill)
        end
    end)

    -- Optional: Add toggle functionality (press F1 to toggle)
    local UserInputService = game:GetService("UserInputService")

    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F1 then
            if overlay and overlay.Parent then
                overlay.BlackFrame.Visible = not overlay.BlackFrame.Visible
            end
        end
    end)

    -- Cleanup when overlay is destroyed
    overlay.AncestryChanged:Connect(function()
        if not overlay.Parent then
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end)
end)

-- ========== END ==========
