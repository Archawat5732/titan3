
-- Utility to run scripts concurrently
local function RunConcurrent(fn)
    task.spawn(fn)
end

-- === REJOIN_BYPASS ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()

    local function rejoinServer()
        local ts = game:GetService("TeleportService")
        local p = game:GetService("Players").LocalPlayer
        ts:TeleportToPlaceInstance(game.PlaceId, game.JobId, p)
    end

    local VirtualInputManager = game:GetService("VirtualInputManager")

    function SimulateLeftClick(x, y)
        VirtualInputManager:SendMouseMoveEvent(x, y, game)
        task.wait()
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
        task.wait()
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
        task.wait()
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
        task.wait(0.5)
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
        task.wait(0.5)
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 0)
        task.wait(0.5)
        VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 0)
    end

    function MainSequence()
        task.wait(80)
        rejoinServer()
    end

    MainSequence()
end)

-- === SCRIPT1_2 ===
RunConcurrent(function()
    -- ========================================
    -- COMBINED ROBLOX SCRIPT
    -- Phase 1: Titan Script -> Phase 2: Naruto Script
    -- ========================================
    if _G.Configs["Farm Mode"] == "OP" then
        repeat task.wait() until game:IsLoaded()
        task.wait(6)
        -- ========================================
        -- PHASE 1: TITAN SCRIPT (CODE NO. 1)
        -- ========================================

        local Players = game:GetService("Players")
        local VirtualInputManager = game:GetService("VirtualInputManager")
        local player = Players.LocalPlayer
        local titanFolder = workspace:WaitForChild("Titans")

        local pressed1 = false
        local pressed2 = false
        local stopLoop = false

        -- Function to anchor character to prevent movement
        local function AnchorCharacter()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")

            if hrp then
                hrp.Anchored = true
                -- Store original position
                return hrp.CFrame
            end
            return nil
        end

        -- Function to unanchor character
        local function UnanchorCharacter()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if hrp then
                hrp.Anchored = false
            end
        end

        -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° 1 (with anti-movement)
        task.delay(1, function()
            local originalPos = AnchorCharacter()

            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.One, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.One, false, game)

            -- Wait a bit for skill animation, then restore position
            task.wait(0.5)
            if originalPos then
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = originalPos
                end
            end

            UnanchorCharacter()
            pressed1 = true
        end)

        -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° 2 (with anti-movement)
        task.delay(4, function()
            local originalPos = AnchorCharacter()

            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
            task.wait(0.1)
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)

            -- Wait a bit for skill animation, then restore position
            task.wait(0.5)
            if originalPos then
                local character = player.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.CFrame = originalPos
                end
            end

            UnanchorCharacter()
            pressed2 = true
        end)

        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏´‡∏¢‡∏∏‡∏î loop ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏Ñ‡∏£‡∏ö
        task.spawn(function()
            while not stopLoop do
                if pressed1 and pressed2 then
                    stopLoop = true
                end
                task.wait(0.1)
            end
        end)

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡πÑ‡∏ó‡∏ó‡∏±‡∏ô‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
        local function getAllTitansInFolder(folder)
            local titans = {}

            for _, descendant in pairs(folder:GetDescendants()) do
                if descendant:FindFirstChild("HumanoidRootPart") then
                    table.insert(titans, descendant)
                end
            end

            return titans
        end

        -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏¢‡πâ‡∏≤‡∏¢‡πÅ‡∏•‡∏∞‡∏Ç‡∏¢‡∏≤‡∏¢ Nape
        local function moveAllNapesLowerInFront()
            local character = player.Character
            if not character then return end

            local hrp = character:FindFirstChild("HumanoidRootPart")
            if not hrp then return end

            local distance = 30
            local dropAmount = 5
            local lookVector = hrp.CFrame.LookVector
            local frontPosition = hrp.Position + lookVector * distance
            local loweredPosition = frontPosition - Vector3.new(0, dropAmount, 0)

            local allTitans = getAllTitansInFolder(titanFolder)

            for _, titan in pairs(allTitans) do
                local nape = titan:FindFirstChild("Hitboxes", true)
                    and titan.Hitboxes:FindFirstChild("Hit", true)
                    and titan.Hitboxes.Hit:FindFirstChild("Nape")

                if nape and nape:IsA("BasePart") then
                    nape.Size = Vector3.new(50, 50, 50)
                    nape.CFrame = CFrame.new(loweredPosition, loweredPosition + lookVector)
                end
            end
        end

        -- Loop ‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á Phase 1
        while true do
            if stopLoop then
                break
            end
            moveAllNapesLowerInFront()
            task.wait(0.05)
        end
    end

    -- ========================================
    -- TRANSITION PHASE
    -- ========================================


    -- ========================================
    -- PHASE 2: NARUTO SCRIPT (CODE NO. 2)
    -- ========================================

    --setfpscap(17) -- Increased from 15 for smoother performance
    task.wait(1)

    -- Services
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local UserInputService = game:GetService("UserInputService")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local RunService = game:GetService("RunService")
    local TweenService = game:GetService("TweenService")

    -- Remotes with better error handling
    local Assets = ReplicatedStorage:WaitForChild("Assets", 10)
    if not Assets then
        return
    end

    local Remotes = Assets:WaitForChild("Remotes", 10)
    if not Remotes then
        return
    end

    local POST = Remotes:WaitForChild("POST", 10)
    local GET = Remotes:WaitForChild("GET", 10)

    if not POST or not GET then
        return
    end

    local LocalPlayer = Players.LocalPlayer

    -- CONFIGURATION SECTION
    -- Base wait time before allowing last titan kill (in seconds)
    local BASE_WAIT_TIME = _G.Configs["BASE_WAIT_TIME"] -- Change this value as needed

    -- Random delay range to add to the base wait time
    -- Set the minimum and maximum additional seconds to add to the base wait time
    -- Example: {1, 3} will add 1-3 random seconds, {1, 5} will add 1-5 random seconds
    local RANDOM_DELAY_CONFIG = { 1, 5 } -- Change these values as needed

    -- Optimized Variables
    local State = {
        baitDummy = nil,
        lastKillValue = -1,
        lastKillTime = tick(),
        lastReloadedKill = -5,
        hasEscaped = false,
        noKillCount = 0,
        isAttacking = false,
        lastActionTime = tick(),
        maxIdleTime = 8, -- Reduced for better responsiveness
        isImmortal = false,
        lastHealthCheck = 0,
        titanCache = {},
        lastTitanCheck = 0,
        gameStartTime = tick(), -- Track when the game/script started
        randomDelayTime = 0     -- Will store the random delay time
    }

    -- Optimized character waiting
    local function WaitForCharacter()
        local startTime = tick()
        repeat
            task.wait(0.1)
            if tick() - startTime > 30 then -- Timeout after 30 seconds
                return false
            end
        until LocalPlayer.Character
            and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            and not LocalPlayer.Character:FindFirstChild("ForceField")

        task.wait(1) -- Reduced wait time
        return true
    end

    -- Optimized HUD waiting with timeout
    local function WaitForKillHUD()
        local startTime = tick()

        while tick() - startTime < 20 do -- 20 second timeout
            local success, result = pcall(function()
                local gui = LocalPlayer:FindFirstChild("PlayerGui")
                if not gui then return false end

                local hudPath = gui:FindFirstChild("Interface")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("HUD")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Objectives")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Main")
                if not hudPath then return false end

                hudPath = hudPath:FindFirstChild("Slay")
                if not hudPath then return false end

                local text = hudPath.Text
                return text and string.match(text, "%[(%d+)%/") ~= nil
            end)

            if success and result then
                return true
            end

            task.wait(0.5)
        end

        return false
    end

    -- Function to generate random delay time (called once at script start)
    local function GenerateRandomDelay()
        if #RANDOM_DELAY_CONFIG >= 2 then
            local minDelay = math.min(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
            local maxDelay = math.max(RANDOM_DELAY_CONFIG[1], RANDOM_DELAY_CONFIG[2])
            return math.random(minDelay, maxDelay)
        else
            return 0 -- No delay if config is invalid
        end
    end

    -- Function to check if required time has passed since game start (base time + random delay)
    local function HasRequiredTimePassed()
        local requiredTime = BASE_WAIT_TIME + State.randomDelayTime
        return (tick() - State.gameStartTime) >= requiredTime
    end

    -- Function to get total required wait time
    local function GetTotalRequiredTime()
        return BASE_WAIT_TIME + State.randomDelayTime
    end

    -- Optimized dummy creation
    local function CreateBaitDummy()
        pcall(function()
            if State.baitDummy then
                State.baitDummy:Destroy()
                State.baitDummy = nil
            end

            local char = LocalPlayer.Character
            if not char or not char.PrimaryPart then return end

            State.baitDummy = char:Clone()
            State.baitDummy.Name = "BaitDummy_" .. math.random(1000, 9999)
            State.baitDummy.Parent = workspace

            -- Position dummy above character
            State.baitDummy:SetPrimaryPartCFrame(char.PrimaryPart.CFrame * CFrame.new(0, 8, 0))

            -- Optimize dummy properties in batch
            local descendants = State.baitDummy:GetDescendants()
            for i = 1, #descendants do
                local part = descendants[i]
                if part:IsA("BasePart") then
                    part.Anchored = true
                    part.CanCollide = false
                    part.Material = Enum.Material.ForceField -- Lighter rendering
                elseif part:IsA("Humanoid") then
                    part.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None
                    part.PlatformStand = true
                    part.BreakJointsOnDeath = false
                    part.Health = part.MaxHealth
                end
            end
        end)
    end

    -- Optimized hiding function
    local function HideCharacter()
        local char = LocalPlayer.Character
        local root = char and char:FindFirstChild("HumanoidRootPart")
        if root then
            root.CFrame = CFrame.new(math.random(-100, 100), -5000, math.random(-100, 100))
        end
    end

    -- Optimized invisibility function
    local function BecomeInvisible()
        local char = LocalPlayer.Character
        if not char then return end

        pcall(function()
            local descendants = char:GetDescendants()
            for i = 1, #descendants do
                local obj = descendants[i]
                if obj:IsA("BasePart") then
                    obj.Transparency = 1
                    obj.CanCollide = false
                elseif obj:IsA("Decal") then
                    obj.Transparency = 1
                elseif obj:IsA("ParticleEmitter") or obj:IsA("Beam") then
                    obj.Enabled = false
                end
            end

            -- Handle accessories
            local children = char:GetChildren()
            for i = 1, #children do
                local acc = children[i]
                if acc:IsA("Accessory") then
                    local handle = acc:FindFirstChild("Handle")
                    if handle then
                        handle.Transparency = 1
                        handle.CanCollide = false
                    end
                end
            end
        end)
    end

    -- Enhanced immortality system
    local function MakeImmortal()
        if State.isImmortal then return end

        local char = LocalPlayer.Character
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")
        if not humanoid then
            return
        end

        pcall(function()
            -- Rename humanoid to avoid detection
            humanoid.Name = "H_" .. math.random(10000, 99999)

            -- Set immortal properties
            humanoid.MaxHealth = 1e6
            humanoid.Health = humanoid.MaxHealth
            humanoid.BreakJointsOnDeath = false
            humanoid.RequiresNeck = false

            -- Continuous health monitoring (optimized)
            local healthConnection
            healthConnection = RunService.Heartbeat:Connect(function()
                if not humanoid or not humanoid.Parent or not char or not char.Parent then
                    if healthConnection then
                        healthConnection:Disconnect()
                    end
                    State.isImmortal = false
                    return
                end

                -- Only check health every 0.1 seconds for performance
                local currentTime = tick()
                if currentTime - State.lastHealthCheck >= 0.1 then
                    State.lastHealthCheck = currentTime
                    if humanoid.Health < humanoid.MaxHealth * 0.9 then
                        humanoid.Health = humanoid.MaxHealth
                    end
                end
            end)

            State.isImmortal = true
            HideCharacter()
            CreateBaitDummy()
        end)
    end

    -- Optimized reload function
    local function Reload()
        pcall(function()
            local gasStation = workspace:FindFirstChild("Unclimbable")
            if gasStation then
                gasStation = gasStation:FindFirstChild("Reloads")
                if gasStation then
                    gasStation = gasStation:FindFirstChild("GasTanks")
                    if gasStation then
                        gasStation = gasStation:FindFirstChild("Refill")
                        if gasStation then
                            POST:FireServer("Attacks", "Reload", gasStation)
                            State.lastActionTime = tick()
                            return
                        end
                    end
                end
            end

            -- Fallback reload
            POST:FireServer("Attacks", "Reload")
            State.lastActionTime = tick()
        end)
    end

    -- Optimized R key press
    local function PressR()
        pcall(function()
            VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
            task.wait(0.05) -- Reduced wait time
            VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
            State.lastActionTime = tick()
        end)
    end

    -- Smoother teleportation around nape
    local function TeleportAroundNape(nape, count, radius)
        local root = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not root or not nape then return false end

        pcall(function()
            local baseHeight = 8
            for i = 1, count do
                local angle = math.rad((360 / count) * i + math.random(-15, 15))
                local currentRadius = radius + math.random(-1, 1)
                local height = baseHeight + math.sin(tick() * 3 + i) * 2

                local offsetX = math.cos(angle) * currentRadius
                local offsetZ = math.sin(angle) * currentRadius

                local targetCFrame = nape.CFrame * CFrame.new(offsetX, height, offsetZ)
                root.CFrame = targetCFrame

                task.wait(0.03) -- Smoother movement
            end
        end)
        return true
    end

    -- Optimized kill count function
    local function GetCurrentKillCount()
        local success, result = pcall(function()
            local gui = LocalPlayer.PlayerGui
            local text = gui.Interface.HUD.Objectives.Main.Slay.Text
            return tonumber(string.match(text, "%[(%d+)%/"))
        end)
        return success and result or State.lastKillValue
    end

    -- Enhanced titan attack function
    local function AttackTitan(titan)
        if State.isAttacking then return end
        State.isAttacking = true

        local success = pcall(function()
            -- Find nape with better error handling
            local hitboxes = titan:FindFirstChild("Hitboxes", true)
            if not hitboxes then
                return
            end

            local hit = hitboxes:FindFirstChild("Hit")
            if not hit then
                return
            end

            local nape = hit:FindFirstChild("Nape")
            if not nape then
                return
            end


            -- Prepare for attack
            BecomeInvisible()
            MakeImmortal()

            -- Optimize nape hitbox
            nape.Size = Vector3.new(25, 25, 25) -- Larger hitbox for better hit detection
            nape.CanCollide = false
            nape.Transparency = 1
            nape.Shape = Enum.PartType.Ball -- Better collision detection

            -- Enhanced teleportation
            if not TeleportAroundNape(nape, 3, 5) then
                return
            end

            -- Improved attack sequence
            local attackSequence = {
                function() POST:FireServer("Attacks", "Slash", true) end,
                function() task.wait(0.02) end,
                function() POST:FireServer("Hitboxes", "Register", nape, 9999, 0.05) end,
                function() task.wait(0.02) end,
                function() POST:FireServer("Attacks", "Slash", false) end
            }

            for i, action in ipairs(attackSequence) do
                action()
            end

            -- Check kill progress
            local currentKill = GetCurrentKillCount()
            if currentKill and currentKill > State.lastKillValue then
                State.lastKillValue = currentKill
                State.lastKillTime = tick()
                State.lastActionTime = tick()
                State.hasEscaped = false
                State.noKillCount = 0
            end

            -- Smart escape mechanism
            local timeSinceKill = tick() - State.lastKillTime
            if timeSinceKill >= 2 and not State.hasEscaped then
                State.hasEscaped = true
                POST:FireServer("Attacks", "Slash_Escape")
                State.lastKillTime = tick()
            end

            -- Smart reload system
            if currentKill and currentKill % 7 == 0 and currentKill ~= State.lastReloadedKill then
                Reload()
                State.lastReloadedKill = currentKill
            end

            -- Timeout handling
            if timeSinceKill >= 2 then
                PressR()
                Reload()
                State.lastKillTime = tick()
                State.noKillCount = State.noKillCount + 1

                if State.noKillCount >= 2 then
                    PressR()
                    State.noKillCount = 0
                end
            end
        end)

        if not success then
            -- Error handling
        end

        State.isAttacking = false
        State.lastActionTime = tick()
    end

    -- Optimized visibility restoration
    local function MakeVisible()
        local char = LocalPlayer.Character
        if not char then return end

        pcall(function()
            local descendants = char:GetDescendants()
            for i = 1, #descendants do
                local part = descendants[i]
                if part:IsA("BasePart") then
                    part.Transparency = 0
                    part.CanCollide = true
                elseif part:IsA("Decal") then
                    part.Transparency = 0
                elseif part:IsA("ParticleEmitter") or part:IsA("Beam") then
                    part.Enabled = true
                end
            end

            local children = char:GetChildren()
            for i = 1, #children do
                local acc = children[i]
                if acc:IsA("Accessory") then
                    local handle = acc:FindFirstChild("Handle")
                    if handle then
                        handle.Transparency = 0
                        handle.CanCollide = true
                    end
                end
            end
        end)
    end

    -- Enhanced script reset
    local function ResetScript()
        pcall(function()
            if State.baitDummy then
                State.baitDummy:Destroy()
                State.baitDummy = nil
            end
        end)

        State.lastKillValue = -1
        State.lastKillTime = tick()
        State.lastReloadedKill = -5
        State.hasEscaped = false
        State.noKillCount = 0
        State.isAttacking = false
        State.lastActionTime = tick()
        State.isImmortal = false
        State.titanCache = {}
        State.lastTitanCheck = 0
        -- Don't reset gameStartTime as we want to keep track from the very beginning
    end

    -- Optimized titan detection with caching
    local function GetTitans()
        local currentTime = tick()
        if currentTime - State.lastTitanCheck < 0.2 then -- Cache for 0.2 seconds
            return State.titanCache
        end

        State.lastTitanCheck = currentTime
        State.titanCache = {}

        local success, titans = pcall(function()
            local titanFolder = workspace:FindFirstChild("Titans")
            return titanFolder and titanFolder:GetChildren() or {}
        end)

        if success then
            -- Filter valid titans
            for i = 1, #titans do
                local titan = titans[i]
                if titan and titan.Parent and titan:FindFirstChild("Hitboxes", true) then
                    table.insert(State.titanCache, titan)
                end
            end
        end

        return State.titanCache
    end

    -- Function to check if we should attack the last titan
    local function ShouldAttackLastTitan(titanCount)
        if titanCount ~= 1 then
            return true -- Not the last titan, attack normally
        end

        -- This is the last titan, check if required time has passed
        return HasRequiredTimePassed()
    end

    -- Initialize Phase 2

    if not WaitForCharacter() then
        error("‚ùå Failed to load character for Phase 2")
    end

    WaitForKillHUD()
    ResetScript()

    -- Generate the random delay time once at the start
    State.randomDelayTime = GenerateRandomDelay()

    -- Main optimized loop for Phase 2
    while true do
        local loopStart = tick()

        -- Anti-hang protection
        if tick() - State.lastActionTime > State.maxIdleTime then
            ResetScript()
            PressR()
        end

        -- Character validation
        local char = LocalPlayer.Character
        if not char or not char:FindFirstChild("HumanoidRootPart") then
            LocalPlayer:LoadCharacter()
            if not WaitForCharacter() then
                continue
            end
            WaitForKillHUD()
            ResetScript()
            task.wait(1)
            continue
        end

        -- Get titans with caching
        local titans = GetTitans()

        if #titans == 0 then
            task.wait(1)
        elseif #titans == 1 then
            -- Single titan strategy with timing check
            if not ShouldAttackLastTitan(#titans) then
                -- Wait for required time to pass before attacking the last titan
                local timeRemaining = GetTotalRequiredTime() - (tick() - State.gameStartTime)
                if timeRemaining > 0 then
                    task.wait(1)
                    continue
                end
            end

            if State.baitDummy then
                pcall(function() State.baitDummy:Destroy() end)
                State.baitDummy = nil
            end

            local titan = titans[1]
            pcall(function()
                char:PivotTo(titan:GetPivot() * CFrame.new(0, 6, -12))
                MakeVisible()
            end)

            AttackTitan(titan)
            task.wait(0.3)
        else
            -- Multiple titans strategy - attack all except potentially the last one
            for i = 1, #titans do
                local isLastTitan = (i == #titans and #titans > 1) -- Check if this is the last titan in a multi-titan scenario

                if not isLastTitan or ShouldAttackLastTitan(1) then
                    AttackTitan(titans[i])
                    task.wait(0.05)
                end
            end
        end

        task.wait(0.05) -- Smooth loop timing
    end
end)

-- === SLOT ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer

    local function MainSequence()
        task.wait(15)
        local selectArgs = { "Functions", "Select", "A" }
        ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(selectArgs))

        local teleportArgs = { "Functions", "Teleport", "Lobby" }
        ReplicatedStorage.Assets.Remotes.GET:InvokeServer(unpack(teleportArgs))
    end

    local success, result = pcall(function()
        return LocalPlayer
            :WaitForChild("PlayerGui")
            :WaitForChild("Interface")
            :WaitForChild("Title_Screen")
            :WaitForChild("Slots").Name
    end)

    if success and typeof(result) == "string" then
        MainSequence()
    else
        warn("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏î‡∏∂‡∏á Slot ‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà string")
    end
end)

-- === CHECK_RETRY ===
RunConcurrent(function()
    -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏Å‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à
    repeat task.wait() until game:IsLoaded()

    -- ‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏® Services
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local UserInputService = game:GetService("UserInputService")
    local delayTime = math.random() * (3.7 - 1.0) + 1.0

    -- ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
    local CONFIG = {
        CLICK_DELAY = 0.1,                    -- ‡∏•‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏≠‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Ñ‡∏•‡∏¥‡∏Å
        CHECK_INTERVAL = 0.5,                 -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏∏‡∏Å 0.5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        INITIAL_WAIT = 5,                     -- ‡∏£‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô 5 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        STUCK_TIMEOUT = 20,                   -- ‡∏ñ‡πâ‡∏≤ Kill ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô 20 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ ‡∏à‡∏∞‡∏Ñ‡∏•‡∏¥‡∏Å
        CLICK_POSITION = _G.Configs["PositionXY"],
    }

    -- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° Kill count
    local lastKillCount = nil
    local lastChangeTime = tick()

    -- üñ± ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÅ‡∏•‡πâ‡∏ß
    local function SimulateLeftClick(x, y)
        local pos = { x = x or CONFIG.CLICK_POSITION.x, y = y or CONFIG.CLICK_POSITION.y }


        -- ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà 1: ‡πÉ‡∏ä‡πâ VirtualInputManager (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á)
        local clickSuccess = pcall(function()
            -- ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
            VirtualInputManager:SendMouseMoveEvent(pos.x, pos.y, game)
            task.wait(CONFIG.CLICK_DELAY)

            -- ‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ã‡πâ‡∏≤‡∏¢ - ‡πÉ‡∏ä‡πâ‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
            -- SendMouseButtonEvent(x, y, button, pressed, game, [button_number])
            VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, true, game, 1)
            task.wait(CONFIG.CLICK_DELAY)
            VirtualInputManager:SendMouseButtonEvent(pos.x, pos.y, 0, false, game, 1)
        end)

        if not clickSuccess then
            -- ‡∏ß‡∏¥‡∏ò‡∏µ‡∏ó‡∏µ‡πà 2: ‡πÉ‡∏ä‡πâ Mouse object (‡∏™‡∏≥‡∏£‡∏≠‡∏á)
            pcall(function()
                if LocalPlayer and LocalPlayer:GetMouse() then
                    local mouse = LocalPlayer:GetMouse()

                    -- ‡∏û‡∏¢‡∏≤‡∏¢‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏î‡πâ‡∏ß‡∏¢‡∏ß‡∏¥‡∏ò‡∏µ‡∏≠‡∏∑‡πà‡∏ô
                    mouse.X = pos.x
                    mouse.Y = pos.y

                    -- ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ú‡πà‡∏≤‡∏ô Mouse events
                    for i = 1, 1 do -- ‡∏•‡∏î‡∏à‡∏≤‡∏Å 2 ‡πÄ‡∏õ‡πá‡∏ô 1 ‡∏Ñ‡∏£‡∏±‡πâ‡∏á
                        if mouse.Button1Down then
                            mouse.Button1Down:Fire()
                        end
                        task.wait(CONFIG.CLICK_DELAY)
                        if mouse.Button1Up then
                            mouse.Button1Up:Fire()
                        end
                        task.wait(CONFIG.CLICK_DELAY)
                    end
                end
            end)
        end

        -- ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á
        task.wait(0.1)
        local mouse = LocalPlayer:GetMouse()
        if mouse then
            local actualX, actualY = mouse.X, mouse.Y

            -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            local xDiff = math.abs(actualX - pos.x)
            local yDiff = math.abs(actualY - pos.y)
        end
    end

    -- üîç ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• Kill count
    local function GetKillData()
        local success, result = pcall(function()
            local interface = LocalPlayer.PlayerGui:FindFirstChild("Interface")
            if not interface then return nil end

            local hud = interface:FindFirstChild("HUD")
            if not hud then return nil end

            local objectives = hud:FindFirstChild("Objectives")
            if not objectives then return nil end

            local main = objectives:FindFirstChild("Main")
            if not main then return nil end

            local slay = main:FindFirstChild("Slay")
            if not slay then return nil end

            return slay.Text
        end)

        return success and result or nil
    end

    -- üìä ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏õ‡πá‡∏ô‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç
    local function ParseKillText(text)
        if not text then return nil, nil end

        local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
        return tonumber(current), tonumber(max)
    end

    -- üéØ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß
    local function MainSequence()
        while true do
            local killText = GetKillData()
            local currentTime = tick()

            if killText then
                local currentKill, maxKill = ParseKillText(killText)

                if currentKill and maxKill then
                    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Kill count ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if lastKillCount ~= currentKill then
                        lastKillCount = currentKill
                        lastChangeTime = currentTime
                    end

                    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏£‡∏ö‡πÅ‡∏•‡πâ‡∏ß‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if currentKill >= maxKill then
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        break
                    end

                    -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ Kill ‡∏Ñ‡πâ‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô timeout ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    local timeSinceLastChange = currentTime - lastChangeTime
                    if timeSinceLastChange >= CONFIG.STUCK_TIMEOUT then
                        task.wait(delayTime)
                        SimulateLeftClick()
                        task.wait(delayTime)
                        SimulateLeftClick()
                        lastChangeTime = currentTime -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏ß‡∏•‡∏≤
                        task.wait(delayTime)         -- ‡∏£‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                    end
                end
            else
            end

            task.wait(CONFIG.CHECK_INTERVAL)
        end
    end

    -- üîß ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
    local function Initialize()
        task.wait(CONFIG.INITIAL_WAIT)

        -- ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ LocalPlayer ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô
        if not LocalPlayer then
            return
        end


        -- ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
        lastChangeTime = tick()

        -- ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏´‡∏•‡∏±‡∏Å
        local success, err = pcall(MainSequence)
        if not success then
            return
        end
    end

    -- üß™ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö‡∏Ñ‡∏•‡∏¥‡∏Å (‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°)
    local function TestClick()
        SimulateLeftClick()
    end

    -- ‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ó‡∏î‡∏™‡∏≠‡∏ö
    _G.TestClick = TestClick

    Initialize()
end)

-- === MISSION ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    task.wait(13)

    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RemoteFunction = ReplicatedStorage.Assets.Remotes.GET

    local gold = Players.LocalPlayer.PlayerGui.Interface.Topbar.Main.Currencies.Gold.Amount.Text
    local gradeText = Players.LocalPlayer.PlayerGui.Interface.Equipment.Categories.Upgrades.Main.Title.Text

    -- ‡∏î‡∏∂‡∏á‡πÄ‡∏Å‡∏£‡∏î ‡πÄ‡∏ä‡πà‡∏ô "B", "A-", "S+" ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° [B+ GRADE]
    local extractedGrade = string.match(gradeText, "%[(%a%+?%-?)%s*GRADE%]")

    -- ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡πÑ‡∏î‡πâ‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ
    local maxChecks = _G.Configs["MaxChecks"]

    -- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    local function performUpgrades()
        local upgrades = {
            "ODM_Range",
            "ODM_Control",
            "ODM_Speed",
            "ODM_Gas",
            "ODM_Damage",
            "Blade_Durability",
            "Crit_Chance",
            "Crit_Damage"
        }

        for _, upgradeName in ipairs(upgrades) do
            local nilCount = 0

            while nilCount < maxChecks do
                local result = RemoteFunction:InvokeServer(unpack({
                    "S_Equipment",
                    "Upgrade",
                    upgradeName
                }))

                if result == nil then
                    nilCount += 1
                    print(string.format("%s is nil (%d/%d)", upgradeName, nilCount, maxChecks))
                else
                    print(upgradeName .. " returned non-nil. Retrying...")
                    nilCount = 0 -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏à‡∏≠‡∏Ñ‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà nil ‡πÉ‡∏´‡πâ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏ô‡∏±‡∏ö‡πÉ‡∏´‡∏°‡πà
                end

                task.wait(1)
            end

            print(upgradeName .. " upgrade attempts done.")
        end
    end

    local function createMission(difficulty, missionType, name, objective)
        local args = { "S_Missions", "Create", {
            ["Difficulty"] = difficulty,
            ["Type"] = missionType,
            ["Name"] = name,
            ["Objective"] = objective
        } }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    local function modifyMission(modifier)
        local args = { "S_Missions", "Modify", modifier }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    local function startMission()
        local args = { "S_Missions", "Start" }
        return RemoteFunction:InvokeServer(unpack(args))
    end

    if typeof(gold) == "string" then
        -- ‡∏ñ‡πâ‡∏≤‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô S, S+, ‡∏´‡∏£‡∏∑‡∏≠ S- ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î
        if extractedGrade == "S" or extractedGrade == "S+" or extractedGrade == "S-" then
            print("Grade is already S-level. Skipping upgrades.")
        else
            print("Grade is below S. Performing upgrades...")
            performUpgrades()
        end

        -- ‡∏™‡∏£‡πâ‡∏≤‡∏á mission
        createMission(_G.Configs["Mission Difficulty"], "Missions", "Shiganshina", "Skirmish")

        for _, modifier in ipairs(_G.Configs["Modifiers"]) do
            modifyMission(modifier)
            task.wait(0.1)
        end

        startMission()
    else
        warn("gold ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà string")
    end
end)




-- === BLACK OVERLAY ===
RunConcurrent(function()
    repeat task.wait() until game:IsLoaded()
    task.wait(5)
    -- Black Screen Overlay with Kill Counter (Ultra Lightweight)
    -- This creates a black overlay with kill counter that doesn't consume much resources

    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local LocalPlayer = Players.LocalPlayer

    -- Wait for PlayerGui
    local playerGui = LocalPlayer:WaitForChild("PlayerGui")

    -- Variables for kill tracking
    local killLabel = nil
    local lastUpdateTime = 0

    -- Optimized kill count function
    local function GetKillInfo()
        local success, currentKill, maxKill = pcall(function()
            local gui = LocalPlayer.PlayerGui
            local text = gui.Interface.HUD.Objectives.Main.Slay.Text
            local current, max = string.match(text, "%[(%d+)%/(%d+)%]")
            return tonumber(current), tonumber(max)
        end)
        return success and currentKill or 0, success and maxKill or 0
    end

    -- Create the black overlay with kill counter
    local function CreateBlackOverlay()
        -- Check if overlay already exists
        local existingOverlay = playerGui:FindFirstChild("BlackOverlay")
        if existingOverlay then
            existingOverlay:Destroy()
        end

        -- Create ScreenGui
        local screenGui = Instance.new("ScreenGui")
        screenGui.Name = "BlackOverlay"
        screenGui.ResetOnSpawn = false
        screenGui.IgnoreGuiInset = true
        screenGui.DisplayOrder = -1000 -- Put it behind other UIs
        screenGui.Parent = playerGui

        -- Create black frame
        local blackFrame = Instance.new("Frame")
        blackFrame.Name = "BlackFrame"
        blackFrame.Size = UDim2.new(1, 0, 1, 0)
        blackFrame.Position = UDim2.new(0, 0, 0, 0)
        blackFrame.BackgroundColor3 = Color3.new(0, 0, 0) -- Pure black
        blackFrame.BorderSizePixel = 0
        blackFrame.Active = false                         -- Don't capture input
        blackFrame.Parent = screenGui

        -- Create kill counter label (simple white text)
        killLabel = Instance.new("TextLabel")
        killLabel.Name = "KillCounter"
        killLabel.Size = UDim2.new(0, 200, 0, 50)
        killLabel.Position = UDim2.new(0.5, -100, 0.5, -25) -- Center of screen
        killLabel.BackgroundTransparency = 1                -- Transparent background
        killLabel.Text = "Kills: 0/0"
        killLabel.TextColor3 = Color3.new(1, 1, 1)          -- White text
        killLabel.TextSize = 24
        killLabel.Font = Enum.Font.Code                     -- Simple font
        killLabel.TextStrokeTransparency = 0.5              -- Slight outline for visibility
        killLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
        killLabel.Active = false
        killLabel.Parent = blackFrame


        return screenGui
    end

    -- Create the overlay
    local overlay = CreateBlackOverlay()

    -- Ultra lightweight update function (updates only every 0.5 seconds)
    local connection = RunService.Heartbeat:Connect(function()
        local currentTime = tick()
        if currentTime - lastUpdateTime >= 0.5 and killLabel and killLabel.Parent then -- Update every 0.5 seconds only
            lastUpdateTime = currentTime
            local currentKill, maxKill = GetKillInfo()
            killLabel.Text = string.format("Kills: %d/%d", currentKill, maxKill)
        end
    end)

    -- Optional: Add toggle functionality (press F1 to toggle)
    local UserInputService = game:GetService("UserInputService")

    UserInputService.InputBegan:Connect(function(input)
        if input.KeyCode == Enum.KeyCode.F1 then
            if overlay and overlay.Parent then
                overlay.BlackFrame.Visible = not overlay.BlackFrame.Visible
            end
        end
    end)

    -- Cleanup when overlay is destroyed
    overlay.AncestryChanged:Connect(function()
        if not overlay.Parent then
            if connection then
                connection:Disconnect()
                connection = nil
            end
        end
    end)
end)

-- ========== END ==========
